#!/usr/bin/env python

# Copyright (c) 2013 Olle Lundberg <geek@nerd.sh>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
#     The above copyright notice and this permission notice shall be included in
#     all copies or substantial portions of the Software.
#
#     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#     FROM,
#     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#     THE SOFTWARE.

__version__ = "0.5.0"

# Wonder why this hack is here? Please check:
# https://bugzilla.redhat.com/show_bug.cgi?id=882016
import sys
sys.path.insert(0, '/usr/lib/python2.6/site-packages/Jinja2-2.6-py2.6.egg')

from gevent import monkey
monkey.patch_all()

import io
import os
import time
import gevent
from gevent.queue import JoinableQueue
from flask import Flask, Response, render_template_string

directory_list_template = """
<!doctype html>
<head>
<title>Webtail</title>
</head>
<body>
<p>
Welcome to Webtail, you can choose to stream <a href="/stream/all">all</a>
files in separate containers or stream all files
<a href="/stream/all/interleaved">interleaved</a> in the same container
</p>
<p>You can also choose to stream one file at the time:<br>
{% for file in files %}
<a href="/stream/raw/{{file}}">{{file}}</a><br>
{% endfor %}
</p>
</body>
</html>
"""

stream_all_template = """
<!doctype html>
<head>
<title>Webtail</title>
<style>
html, body, form, div.interleaved {
width: 100%;
height: 100%;
}

div {
width: 50%;
float: left;
}

iframe {
width: 100%;
height: 90%
}
</style>
</head>
<body>
<form>
{% for file in files %}
<div class="{{file}}"><label><input type="checkbox" data-target="{{file}}"
checked>Autoscroll {{file}}</label><br>
<iframe src="{{path}}{{file}}" id="{{file}}"></iframe>
</div>
{% endfor %}
</form>

<script type="text/javascript">
setInterval(function autoScroll() {
    console.log("Running");
    var checkboxes = document.querySelectorAll('input:checked');

    for(var i = 0; i < checkboxes.length; i+=1) {
        var checkbox = checkboxes[i];
        var iframe = document.getElementById(checkbox.getAttribute("data-target"));
        iframe.contentWindow.document.body.scrollTop+=20;
    }
    }, 10)
</script>
</body>
</html>
"""

app = Flask(__name__)


def tail(thefile):
    fd = io.open(thefile, 'r')
    fd.seek(0)
    while True:
        line = fd.readline()
        if not line:
            # Sleep for a short while. This allows gevent to swith to another
            # greenlet. It also won't force the cpu to spike.
            time.sleep(0.001)
            continue
        yield line


def tail_to_queue(thefile, queue):
    for line in tail(thefile):
        queue.put((thefile, line, ))
        time.sleep(0.001)
        # The aboce sleep let's gevent schedule another greenlet.
        # This gives the effect (noticed in the interleaved route)
        # that we are able to put stuff in the queue from many concurrent
        # tails. Without we would have read one file until that tail waits
        # for more lines, which in a busy environment might take a *really*
        # long time.


def spawn_and_yield_from_queue(queue):
    for thefile in files():
        gevent.spawn(tail_to_queue, thefile, queue)

    while True:
        yield "{0}: {1}".format(*queue.get())


def files():
    return (item for item in os.listdir(os.curdir) if os.path.isfile(item))


@app.route('/')
def index():
    return render_template_string(directory_list_template,
                                  files=files()
                                  )


@app.route("/stream/all")
def stream_all():
    return render_template_string(stream_all_template,
                                  files=files(),
                                  path="/stream/raw/"
                                  )


@app.route("/stream/all/interleaved")
def stream_all_interleaved():
    return render_template_string(stream_all_template,
                                  files=['interleaved'],
                                  path="/stream/all/raw/"
                                  )


@app.route("/stream/raw/<thefile>")
def raw(thefile):
    return Response(tail(thefile),
                    mimetype='text/plain'
                    )


@app.route("/stream/all/raw/interleaved")
def stream_all_raw_interleaved():
    return Response(spawn_and_yield_from_queue(JoinableQueue()),
                    mimetype='text/plain'
                    )

if __name__ == '__main__':
    from optparse import OptionParser
    from gevent.pywsgi import WSGIServer

    usage = "usage: %prog [options]"
    parser = OptionParser(usage=usage)
    parser.add_option("-D", "--debug",
                      action="store_true",
                      default=False,
                      dest="debug",
                      help="turn on debug for the flask application, defaults to False"
                      )
    parser.add_option("-d", "--directory",
                      action="store",
                      default='.',
                      dest="directory",
                      metavar="DIR",
                      help="read from DIR, defaults to '.'"
                      )
    parser.add_option("-l", "--listen",
                      action="store",
                      default='',
                      dest="listen",
                      metavar="ADDRESS",
                      help="bind to ADDRESS, defaults to all"
                      )
    parser.add_option("-p", "--port",
                      action="store",
                      default=5000,
                      dest="port",
                      metavar="PORT",
                      type="int",
                      help="bind to PORT, default to 5000"
                      )
    parser.add_option("-q", "--quiet",
                      action="store_true",
                      default=False,
                      dest="quiet",
                      help="makes webtail quieter."
                      )

    (options, args) = parser.parse_args()

    logdest = "default"

    app.debug = options.debug
    os.chdir(options.directory)

    # Here we go!
    if options.quiet:
        logdest = None
        stdout = sys.stdout
        stderr = sys.stderr
        sys.stdout = io.open(os.devnull)
        sys.stderr = io.open(os.devnull)

    http_server = WSGIServer((options.listen, options.port), app, log=logdest)
    try:
        http_server.serve_forever()
    except KeyboardInterrupt:
        pass

# vim: set expandtab:ts=4:sw=4
